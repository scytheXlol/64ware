local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/jensonhirst/Orion/main/source')))()

local Window = OrionLib:MakeWindow({Name = "64ware.cc V0.62", HidePremium = true, SaveConfig = false, ConfigFolder = "OrionTest"})
local Tab = Window:MakeTab({
	Name = "Credits",
	Icon = "rbxassetid://18449541318",
	PremiumOnly = false
})

local Section = Tab:AddSection({
	Name = "HTTPS://DISCORD.GG/5sbWnpXF"
})

local Section = Tab:AddSection({
	Name = "MADE BY @SSW0RD64 FOR 64SQUAD"
})

local Section = Tab:AddSection({
	Name = "more features coming soon..."
})

local Tab = Window:MakeTab({
	Name = "64ware.cc",
	Icon = "rbxassetid://14916455451",
	PremiumOnly = false
})

local Section = Tab:AddSection({
	Name = "64WARE.CC CURRENT VERSION - V0.62 BETA"
})

local Section = Tab:AddSection({
	Name = "Aimbot (Hold RMB on enemy to use)"
})

Tab:AddButton({
	Name = "Aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = true
_G.TeamCheck = true -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

Tab:AddButton({
	Name = "Wallcheck aimbot (May not work in kay's)",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = true
_G.TeamCheck = true -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = true -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

Tab:AddButton({
	Name = "No TeamCheck aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = true
_G.TeamCheck = false -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

Tab:AddButton({
	Name = "RootPart Aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = true
_G.TeamCheck = true -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "HumanoidRootPart" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

Tab:AddButton({
	Name = "Off aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = false
_G.TeamCheck = false -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

local Section = Tab:AddSection({
	Name = "Legit"
})

Tab:AddButton({
	Name = "Aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = true
_G.TeamCheck = true -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.1 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 70 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.10, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

Tab:AddButton({
	Name = "Off aimbot",
	Callback = function()
      		local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")

local LocalPlayer = Players.LocalPlayer
local Holding = false
local Target = nil

_G.AimbotEnabled = false
_G.TeamCheck = false -- If set to true then the script would only lock your aim at enemy team members.
_G.AimPart = "Head" -- Where the aimbot script would lock at.
_G.Sensitivity = 0.0 -- How many seconds it takes for the aimbot script to officially lock onto the target's aimpart.
_G.FOV = 90 -- Field of View in degrees
_G.AimOffset = Vector3.new(0, 0.05, 0) -- Offset to aim slightly below the target's head
_G.CheckWalls = false -- Enable or disable wall check

local function IsPointVisible(startPosition, endPosition, targetPlayer)
    local direction = (endPosition - startPosition).unit
    local distance = (endPosition - startPosition).magnitude
    local ray = Ray.new(startPosition, direction * distance)

    -- Создаем RaycastParams и настраиваем его
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude

    -- Выполняем Raycast
    local result = workspace:Raycast(ray.Origin, ray.Direction, raycastParams)
    return not result
end



local function GetClosestPlayer()
    local MaximumDistance = math.huge
    local ClosestPlayer = nil

    local CameraDirection = Camera.CFrame.LookVector
    local CameraPosition = Camera.CFrame.Position

    for _, v in next, Players:GetPlayers() do
        if v.Name ~= LocalPlayer.Name then
            if _G.TeamCheck == true then
                if v.Team ~= LocalPlayer.Team then
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                        local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                        local DirectionToTarget = (TargetPosition - CameraPosition).unit
                        local DotProduct = CameraDirection:Dot(DirectionToTarget)
                        local Angle = math.acos(DotProduct) * (180 / math.pi)

                        if Angle <= _G.FOV / 2 then
                            local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                            local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                            if VectorDistance < MaximumDistance then
                                if _G.CheckWalls then
                                    if IsPointVisible(CameraPosition, TargetPosition, v) then
                                        ClosestPlayer = v
                                        MaximumDistance = VectorDistance
                                    end
                                else
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            end
                        end
                    end
                end
            else
                if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local TargetPosition = v.Character.HumanoidRootPart.Position + _G.AimOffset
                    local DirectionToTarget = (TargetPosition - CameraPosition).unit
                    local DotProduct = CameraDirection:Dot(DirectionToTarget)
                    local Angle = math.acos(DotProduct) * (180 / math.pi)

                    if Angle <= _G.FOV / 2 then
                        local ScreenPoint = Camera:WorldToScreenPoint(TargetPosition)
                        local MousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        local VectorDistance = (MousePosition - Vector2.new(ScreenPoint.X, ScreenPoint.Y)).Magnitude
                        
                        if VectorDistance < MaximumDistance then
                            if _G.CheckWalls then
                                if IsPointVisible(CameraPosition, TargetPosition, v) then
                                    ClosestPlayer = v
                                    MaximumDistance = VectorDistance
                                end
                            else
                                ClosestPlayer = v
                                MaximumDistance = VectorDistance
                            end
                        end
                    end
                end
            end
        end
    end

    return ClosestPlayer
end


local function ShowDebugInfo()
    if Target then
        local targetName = Target.Name
        local targetPos = Target.Character and Target.Character[_G.AimPart] and Target.Character[_G.AimPart].Position or "N/A"
        print("Current Target: ", targetName, " Position: ", targetPos)
    else
        print("No Target")
    end
end

UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        Holding = false
        Target = nil -- Reset target when the mouse button is released
        
    end
end)

RunService.RenderStepped:Connect(function()
    if Holding and _G.AimbotEnabled then
        if not Target or not Target.Character or not Target.Character:FindFirstChild(_G.AimPart) or Target.Character.Humanoid.Health == 0 then
            Target = GetClosestPlayer()
        end
        if Target and Target.Character and Target.Character:FindFirstChild(_G.AimPart) then
            TweenService:Create(Camera, TweenInfo.new(_G.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Target.Character[_G.AimPart].Position + _G.AimOffset)}):Play()
            ClickMouseButton1(0.1) -- Simulate mouse click when aiming at the target
        end
        ShowDebugInfo() -- Display debug info in the output
    end
end)

local function PressKey(KeyCode, Duration)
    VIM:SendKeyEvent(true, KeyCode, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendKeyEvent(false, KeyCode, false, game)
    end
end

local function ClickMouseButton1(Duration)
    local screenSize = Camera.ViewportSize
    local x = screenSize.X / 2
    local y = screenSize.Y / 2
    
    VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.Begin, false, game)
    if Duration then
        task.wait(Duration)
        VIM:SendMouseButtonEvent(x, y, 0, Enum.UserInputState.End, false, game)
    end
end
  	end    
})

local Section = Tab:AddSection({
	Name = "Visuals"
})

Tab:AddButton({
	Name = "Tracers (X to on/off)",
	Callback = function()
      		local function API_Check()
    if Drawing == nil then
        return "No"
    else
        return "Yes"
    end
end

local Find_Required = API_Check()

if Find_Required == "No" then
    game:GetService("StarterGui"):SetCore("SendNotification",{
        Title = "64ware";
        Text = "Tracer script could not be loaded because your exploit is unsupported.";
        Duration = math.huge;
        Button1 = "OK"
    })

    return
end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = game:GetService("Workspace").CurrentCamera
local UserInputService = game:GetService("UserInputService")
local TestService = game:GetService("TestService")

local Typing = false

_G.SendNotifications = true   -- If set to true then the script would notify you frequently on any changes applied and when loaded / errored. (If a game can detect this, it is recommended to set it to false)
_G.DefaultSettings = false   -- If set to true then the tracer script would run with default settings regardless of any changes you made.

_G.TeamCheck = true   -- If set to true then the script would create tracers only for the enemy team members.

--[!]-- ONLY ONE OF THESE VALUES SHOULD BE SET TO TRUE TO NOT ERROR THE SCRIPT --[!]--

_G.FromMouse = true   -- If set to true, the tracers will come from the position of your mouse curson on your screen.
_G.FromCenter = false   -- If set to true, the tracers will come from the center of your screen.
_G.FromBottom = false   -- If set to true, the tracers will come from the bottom of your screen.

_G.TracersVisible = true   -- If set to true then the tracers will be visible and vice versa.
_G.TracerColor = Color3.fromRGB(255, 80, 10)   -- The color that the tracers would appear as.
_G.TracerThickness = 1.5   -- The thickness of the tracers.
_G.TracerTransparency = 0.7   -- The transparency of the tracers.

_G.ModeSkipKey = Enum.KeyCode.Z   -- The key that changes between modes that indicate where will the tracers come from.
_G.DisableKey = Enum.KeyCode.X   -- The key that disables / enables the tracers.

local function CreateTracers()
    for _, v in next, Players:GetPlayers() do
        if v.Name ~= game.Players.LocalPlayer.Name then
            local TracerLine = Drawing.new("Line")
    
            RunService.RenderStepped:Connect(function()
                if workspace:FindFirstChild(v.Name) ~= nil and workspace[v.Name]:FindFirstChild("HumanoidRootPart") ~= nil then
                    local HumanoidRootPart_Position, HumanoidRootPart_Size = workspace[v.Name].HumanoidRootPart.CFrame, workspace[v.Name].HumanoidRootPart.Size * 1
                    local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart_Position * CFrame.new(0, -HumanoidRootPart_Size.Y, 0).p)
                    
                    TracerLine.Thickness = _G.TracerThickness
                    TracerLine.Transparency = _G.TracerTransparency
                    TracerLine.Color = _G.TracerColor

                    if _G.FromMouse == true and _G.FromCenter == false and _G.FromBottom == false then
                        TracerLine.From = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                    elseif _G.FromMouse == false and _G.FromCenter == true and _G.FromBottom == false then
                        TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    elseif _G.FromMouse == false and _G.FromCenter == false and _G.FromBottom == true then
                        TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    end

                    if OnScreen == true  then
                        TracerLine.To = Vector2.new(Vector.X, Vector.Y)
                        if _G.TeamCheck == true then 
                            if Players.LocalPlayer.Team ~= v.Team then
                                TracerLine.Visible = _G.TracersVisible
                            else
                                TracerLine.Visible = false
                            end
                        else
                            TracerLine.Visible = _G.TracersVisible
                        end
                    else
                        TracerLine.Visible = false
                    end
                else
                    TracerLine.Visible = false
                end
            end)

            Players.PlayerRemoving:Connect(function()
                TracerLine.Visible = false
            end)
        end
    end

    Players.PlayerAdded:Connect(function(Player)
        Player.CharacterAdded:Connect(function(v)
            if v.Name ~= game.Players.LocalPlayer.Name then
                local TracerLine = Drawing.new("Line")
        
                RunService.RenderStepped:Connect(function()
                    if workspace:FindFirstChild(v.Name) ~= nil and workspace[v.Name]:FindFirstChild("HumanoidRootPart") ~= nil then
                        local HumanoidRootPart_Position, HumanoidRootPart_Size = workspace[v.Name].HumanoidRootPart.CFrame, workspace[v.Name].HumanoidRootPart.Size * 1
                    	local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart_Position * CFrame.new(0, -HumanoidRootPart_Size.Y, 0).p)
                        
                        TracerLine.Thickness = _G.TracerThickness
                        TracerLine.Transparency = _G.TracerTransparency
                        TracerLine.Color = _G.TracerColor

                        if _G.FromMouse == true and _G.FromCenter == false and _G.FromBottom == false then
                            TracerLine.From = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                        elseif _G.FromMouse == false and _G.FromCenter == true and _G.FromBottom == false then
                            TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        elseif _G.FromMouse == false and _G.FromCenter == false and _G.FromBottom == true then
                            TracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                        end

                        if OnScreen == true  then
                            TracerLine.To = Vector2.new(Vector.X, Vector.Y)
                            if _G.TeamCheck == true then 
                                if Players.LocalPlayer.Team ~= Player.Team then
                                    TracerLine.Visible = _G.TracersVisible
                                else
                                    TracerLine.Visible = false
                                end
                            else
                                TracerLine.Visible = _G.TracersVisible
                            end
                        else
                            TracerLine.Visible = false
                        end
                    else
                        TracerLine.Visible = false
                    end
                end)

                Players.PlayerRemoving:Connect(function()
                    TracerLine.Visible = false
                end)
            end
        end)
    end)
end

UserInputService.TextBoxFocused:Connect(function()
    Typing = true
end)

UserInputService.TextBoxFocusReleased:Connect(function()
    Typing = false
end)

UserInputService.InputBegan:Connect(function(Input)
    if Input.KeyCode == _G.ModeSkipKey and Typing == false then
        if _G.FromMouse == true and _G.FromCenter == false and _G.FromBottom == false and _G.TracersVisible == true then
            _G.FromCenter = false
            _G.FromBottom = true
            _G.FromMouse = false

            if _G.SendNotifications == true then
                game:GetService("StarterGui"):SetCore("SendNotification",{
                    Title = "64ware";
                    Text = "Tracers will be now coming from the bottom of your screen (Mode 1)";
                    Duration = 5;
                })
            end
        elseif _G.FromMouse == false and _G.FromCenter == false and _G.FromBottom == true and _G.TracersVisible == true then
            _G.FromCenter = true
            _G.FromBottom = false
            _G.FromMouse = false

            if _G.SendNotifications == true then
                game:GetService("StarterGui"):SetCore("SendNotification",{
                    Title = "64ware";
                    Text = "Tracers will be now coming from the center of your screen (Mode 2)";
                    Duration = 5;
                })
            end
        elseif _G.FromMouse == false and _G.FromCenter == true and _G.FromBottom == false and _G.TracersVisible == true then
            _G.FromCenter = false
            _G.FromBottom = false
            _G.FromMouse = true

            if _G.SendNotifications == true then
                game:GetService("StarterGui"):SetCore("SendNotification",{
                    Title = "64ware";
                    Text = "Tracers will be now coming from the position of your mouse cursor on your screen (Mode 3)";
                    Duration = 5;
                })
            end
        end
    elseif Input.KeyCode == _G.DisableKey and Typing == false then
        _G.TracersVisible = not _G.TracersVisible
        
        if _G.SendNotifications == true then
            game:GetService("StarterGui"):SetCore("SendNotification",{
                Title = "Exunys Developer";
                Text = "The tracers' visibility is now set to "..tostring(_G.TracersVisible)..".";
                Duration = 5;
            })
        end
    end
end)

if _G.DefaultSettings == true then
    _G.TeamCheck = false
    _G.FromMouse = false
    _G.FromCenter = false
    _G.FromBottom = true
    _G.TracersVisible = true
    _G.TracerColor = Color3.fromRGB(40, 90, 255)
    _G.TracerThickness = 1
    _G.TracerTransparency = 0.5
    _G.ModeSkipKey = Enum.KeyCode.E
    _G.DisableKey = Enum.KeyCode.Q
end

local Success, Errored = pcall(function()
    CreateTracers()
end)

if Success and not Errored then
    if _G.SendNotifications == true then
        game:GetService("StarterGui"):SetCore("SendNotification",{
            Title = "Exunys Developer";
            Text = "Tracer script has successfully loaded.";
            Duration = 5;
        })
    end
elseif Errored and not Success then
    if _G.SendNotifications == true then
        game:GetService("StarterGui"):SetCore("SendNotification",{
            Title = "64ware";
            Text = "Tracer script has errored while loading, please check the developer console! (F9)";
            Duration = 5;
        })
    end
    TestService:Message("The tracer script has errored, please notify Exunys with the following information :")
    warn(Errored)
    print("!! IF THE ERROR IS A FALSE POSITIVE (says that a player cannot be found) THEN DO NOT BOTHER !!")
end
  	end    
})

Tab:AddButton({
	Name = "ESP Remake",
	Callback = function()
      		_G.FriendColor = Color3.fromRGB(0, 0, 255)
_G.EnemyColor = Color3.fromRGB(255, 0, 0)
_G.UseTeamColor = true

--------------------------------------------------------------------
local Holder = Instance.new("Folder", game.CoreGui)
Holder.Name = "ESP"

local Box = Instance.new("BoxHandleAdornment")
Box.Name = "nilBox"
Box.Size = Vector3.new(1, 2, 1)
Box.Color3 = Color3.new(100 / 255, 100 / 255, 100 / 255)
Box.Transparency = 0.7
Box.ZIndex = 0
Box.AlwaysOnTop = false
Box.Visible = false

local NameTag = Instance.new("BillboardGui")
NameTag.Name = "nilNameTag"
NameTag.Enabled = false
NameTag.Size = UDim2.new(0, 200, 0, 50)
NameTag.AlwaysOnTop = true
NameTag.StudsOffset = Vector3.new(0, 1.8, 0)
local Tag = Instance.new("TextLabel", NameTag)
Tag.Name = "Tag"
Tag.BackgroundTransparency = 1
Tag.Position = UDim2.new(0, -50, 0, 0)
Tag.Size = UDim2.new(0, 300, 0, 20)
Tag.TextSize = 15
Tag.TextColor3 = Color3.new(100 / 255, 100 / 255, 100 / 255)
Tag.TextStrokeColor3 = Color3.new(0 / 255, 0 / 255, 0 / 255)
Tag.TextStrokeTransparency = 0.4
Tag.Text = "nil"
Tag.Font = Enum.Font.SourceSansBold
Tag.TextScaled = false

local LoadCharacter = function(v)
	repeat wait() until v.Character ~= nil
	v.Character:WaitForChild("Humanoid")
	local vHolder = Holder:FindFirstChild(v.Name)
	vHolder:ClearAllChildren()
	local b = Box:Clone()
	b.Name = v.Name .. "Box"
	b.Adornee = v.Character
	b.Parent = vHolder
	local t = NameTag:Clone()
	t.Name = v.Name .. "NameTag"
	t.Enabled = true
	t.Parent = vHolder
	t.Adornee = v.Character:WaitForChild("Head", 5)
	if not t.Adornee then
		return UnloadCharacter(v)
	end
	t.Tag.Text = v.Name
	b.Color3 = Color3.new(v.TeamColor.r, v.TeamColor.g, v.TeamColor.b)
	t.Tag.TextColor3 = Color3.new(v.TeamColor.r, v.TeamColor.g, v.TeamColor.b)
	local Update
	local UpdateNameTag = function()
		if not pcall(function()
			v.Character.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			local maxh = math.floor(v.Character.Humanoid.MaxHealth)
			local h = math.floor(v.Character.Humanoid.Health)
		end) then
			Update:Disconnect()
		end
	end
	UpdateNameTag()
	Update = v.Character.Humanoid.Changed:Connect(UpdateNameTag)
end

local UnloadCharacter = function(v)
	local vHolder = Holder:FindFirstChild(v.Name)
	if vHolder and (vHolder:FindFirstChild(v.Name .. "Box") ~= nil or vHolder:FindFirstChild(v.Name .. "NameTag") ~= nil) then
		vHolder:ClearAllChildren()
	end
end

local LoadPlayer = function(v)
	local vHolder = Instance.new("Folder", Holder)
	vHolder.Name = v.Name
	v.CharacterAdded:Connect(function()
		pcall(LoadCharacter, v)
	end)
	v.CharacterRemoving:Connect(function()
		pcall(UnloadCharacter, v)
	end)
	v.Changed:Connect(function(prop)
		if prop == "TeamColor" then
			UnloadCharacter(v)
			wait()
			LoadCharacter(v)
		end
	end)
	LoadCharacter(v)
end

local UnloadPlayer = function(v)
	UnloadCharacter(v)
	local vHolder = Holder:FindFirstChild(v.Name)
	if vHolder then
		vHolder:Destroy()
	end
end

for i,v in pairs(game:GetService("Players"):GetPlayers()) do
	spawn(function() pcall(LoadPlayer, v) end)
end

game:GetService("Players").PlayerAdded:Connect(function(v)
	pcall(LoadPlayer, v)
end)

game:GetService("Players").PlayerRemoving:Connect(function(v)
	pcall(UnloadPlayer, v)
end)

game:GetService("Players").LocalPlayer.NameDisplayDistance = 0

if _G.Reantheajfdfjdgs then
    return
end

_G.Reantheajfdfjdgs = ":suifayhgvsdghfsfkajewfrhk321rk213kjrgkhj432rj34f67df"

local players = game:GetService("Players")
local plr = players.LocalPlayer

function esp(target, color)
    if target.Character then
        if not target.Character:FindFirstChild("GetReal") then
            local highlight = Instance.new("Highlight")
            highlight.RobloxLocked = true
            highlight.Name = "GetReal"
            highlight.Adornee = target.Character
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.FillColor = color
            highlight.Parent = target.Character
        else
            target.Character.GetReal.FillColor = color
        end
    end
end

while task.wait() do
    for i, v in pairs(players:GetPlayers()) do
        if v ~= plr then
            esp(v, _G.UseTeamColor and v.TeamColor.Color or ((plr.TeamColor == v.TeamColor) and _G.FriendColor or _G.EnemyColor))
        end
    end
end
  	end    
})

local Section = Tab:AddSection({
	Name = "TriggerBot"
})

Tab:AddButton({
	Name = "TriggerBot (Q to activate)",
	Callback = function()
      		local enabled = true
local toggle = Enum.KeyCode.Q
local mouse = game:GetService("Players").LocalPlayer:GetMouse()
game:GetService("RunService").RenderStepped:Connect(function()
    if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") and mouse.Target.Parent:FindFirstChildOfClass("Humanoid").Health > 0 and game:GetService("Players"):GetPlayerFromCharacter(mouse.Target.Parent).Team ~= game:GetService("Players").LocalPlayer.Team and enabled then
        mouse1press()
        repeat
            game:GetService("RunService").RenderStepped:Wait()
        until not mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
        mouse1release()
    end
end)

game:GetService("UserInputService").InputBegan:Connect(function(i,gp)
    if i.KeyCode == toggle then
        enabled = not enabled
        local hint = Instance.new("Hint",game.CoreGui)
        hint.Text = "Toggled: "..tostring(enabled)
        wait(14)
        hint:Destroy()
    end
end)
  	end    
})

local Section = Tab:AddSection({
	Name = "Extra"
})

Tab:AddButton({
	Name = "Infinite Yield (IY)",
	Callback = function()
      		loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
  	end
})

Tab:AddButton({
	Name = "Dex Explorer",
	Callback = function()
      		loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
  	end
})

Tab:AddButton({
	Name = "Noclip",
	Callback = function()
      		local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local Noclip = Instance.new("ScreenGui")
local BG = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local Toggle = Instance.new("TextButton")
local StatusPF = Instance.new("TextLabel")
local Status = Instance.new("TextLabel")
local Plr = Players.LocalPlayer
local Clipon = false

Noclip.Name = "Noclip"
Noclip.Parent = game.CoreGui

BG.Name = "BG"
BG.Parent = Noclip
BG.BackgroundColor3 = Color3.new(0.0980392, 0.0980392, 0.0980392)
BG.BorderColor3 = Color3.new(0.0588235, 0.0588235, 0.0588235)
BG.BorderSizePixel = 2
BG.Position = UDim2.new(0.149479166, 0, 0.82087779, 0)
BG.Size = UDim2.new(0, 210, 0, 127)
BG.Active = true
BG.Draggable = true

Title.Name = "Title"
Title.Parent = BG
Title.BackgroundColor3 = Color3.new(0.266667, 0.00392157, 0.627451)
Title.BorderColor3 = Color3.new(0.180392, 0, 0.431373)
Title.BorderSizePixel = 2
Title.Size = UDim2.new(0, 210, 0, 33)
Title.Font = Enum.Font.Highway
Title.Text = "Noclip"
Title.TextColor3 = Color3.new(1, 1, 1)
Title.FontSize = Enum.FontSize.Size32
Title.TextSize = 30
Title.TextStrokeColor3 = Color3.new(0.180392, 0, 0.431373)
Title.TextStrokeTransparency = 0

Toggle.Parent = BG
Toggle.BackgroundColor3 = Color3.new(0.266667, 0.00392157, 0.627451)
Toggle.BorderColor3 = Color3.new(0.180392, 0, 0.431373)
Toggle.BorderSizePixel = 2
Toggle.Position = UDim2.new(0.152380958, 0, 0.374192119, 0)
Toggle.Size = UDim2.new(0, 146, 0, 36)
Toggle.Font = Enum.Font.Highway
Toggle.FontSize = Enum.FontSize.Size28
Toggle.Text = "Toggle"
Toggle.TextColor3 = Color3.new(1, 1, 1)
Toggle.TextSize = 25
Toggle.TextStrokeColor3 = Color3.new(0.180392, 0, 0.431373)
Toggle.TextStrokeTransparency = 0

StatusPF.Name = "StatusPF"
StatusPF.Parent = BG
StatusPF.BackgroundColor3 = Color3.new(1, 1, 1)
StatusPF.BackgroundTransparency = 1
StatusPF.Position = UDim2.new(0.314285725, 0, 0.708661377, 0)
StatusPF.Size = UDim2.new(0, 56, 0, 20)
StatusPF.Font = Enum.Font.Highway
StatusPF.FontSize = Enum.FontSize.Size24
StatusPF.Text = "Status:"
StatusPF.TextColor3 = Color3.new(1, 1, 1)
StatusPF.TextSize = 20
StatusPF.TextStrokeColor3 = Color3.new(0.333333, 0.333333, 0.333333)
StatusPF.TextStrokeTransparency = 0
StatusPF.TextWrapped = true

Status.Name = "Status"
Status.Parent = BG
Status.BackgroundColor3 = Color3.new(1, 1, 1)
Status.BackgroundTransparency = 1
Status.Position = UDim2.new(0.580952346, 0, 0.708661377, 0)
Status.Size = UDim2.new(0, 56, 0, 20)
Status.Font = Enum.Font.Highway
Status.FontSize = Enum.FontSize.Size14
Status.Text = "off"
Status.TextColor3 = Color3.new(0.666667, 0, 0)
Status.TextScaled = true
Status.TextSize = 14
Status.TextStrokeColor3 = Color3.new(0.180392, 0, 0.431373)
Status.TextWrapped = true
Status.TextXAlignment = Enum.TextXAlignment.Left


Toggle.MouseButton1Click:connect(function()
	if Status.Text == "off" then
		Clipon = true
		Status.Text = "on"
		Status.TextColor3 = Color3.new(0,185,0)
		Stepped = game:GetService("RunService").Stepped:Connect(function()
			if not Clipon == false then
				for a, b in pairs(Workspace:GetChildren()) do
                if b.Name == Plr.Name then
                for i, v in pairs(Workspace[Plr.Name]:GetChildren()) do
                if v:IsA("BasePart") then
                v.CanCollide = false
                end end end end
			else
				Stepped:Disconnect()
			end
		end)
	elseif Status.Text == "on" then
		Clipon = false
		Status.Text = "off"
		Status.TextColor3 = Color3.new(170,0,0)
	end
end)
  	end
})

local Section = Tab:AddSection({
	Name = "RAGE (IN DEV)"
})

OrionLib:Init()
